# 图数据管理与分析实验报告

## 任务一：

按照任务一将数据上传到gStore云平台或者直接使用将数据集中的jinrong.nt文件上传到gStore云平台。利用构建好的知识图谱，编写sparql语句查询两个公司之间的关联路径（2-hop）。例如输入公司“招商局轮船股份有限公司”和“招商银行股份有限公司”，得到这两家公司之间的所有路径。

### SPARQL查询实现
```
# 获取从A两跳到C的路径
SELECT ?p ?o 
WHERE
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/A> ?p ?o .
	?o ?p <file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C>
}
```

### Python调用API实现

```python
def query_two_hop_paths(company1:str,company2:str):
    sql = f'''
        SELECT ?p ?o 
        WHERE{{
            {company1} ?p ?o .
            ?o ?p {company2}
        }}
        '''
    response = send_post(sql)
    return response
```

### 实验测试

#### python 测试代码
```python
def get_two_hop_path(company1,company2):
    result = query_two_hop_paths(company_add_prefix_and_suffix(company1),company_add_prefix_and_suffix(company2))
    for r in result["results"]["bindings"]:
        p = r["p"]["value"]
        o = r["o"]["value"]
        print(f"{(company1)} -> {company_delete_prefix_and_suffix(o)} -> {(company2)}")

if __name__ == "__main__":
    get_two_hop_path("A","C")
```
#### 测试代码输出
```bash
$ python expr1_test.py 
A -> B -> C
```


## 任务二:

编写sparql语言实现多层股权的穿透式查询，可以根据指定层数获得对应层级的股东，例如：输入“招商局轮船股份有限公司””和层数3，就会把“招商局轮船股份有限公司”所对应公司所有三层以内的公司找出来。

### SPARQL查询实现
```bash
# 1 层控股C的公司
select *
{
	?a ?p0 <file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C>
}
# 2 层控股C的公司
select *
{
	?a ?p0 ?b .
	?b ?p1 <file:///F:/d2r-server-0.7/holder8.nt#holder_opy/C>
}
# 3 层控股C的公司
select *
{
	?a ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 <file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C>
}
# 4 层控股C的公司
select *
{
	?a ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 ?d .
	?d ?p3 <file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C>
}
# C控股的1层公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C> ?p0 ?b 
}
# C控股的2层公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_opy/C> ?p0 ?b .
	?b ?p1 ?c 
}
# C控股的3层公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C> ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 ?d 
}
# C控股的4层公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C> ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 ?d .
	?d ?p3 ?e 
}
```
### Python调用API实现
```python
def query_pre_n_layer_company(company:str,layer:int):
    assert layer <= 9
    company_candidate = ["?a", "?b", "?c", "?d", "?e", "?f", "?g", "?h", "?i", "?j"]
    sql_object_list = []
    for i in range(layer):
        sql_object_list.append(company_candidate[i])
        sql_object_list.append("?p")
        sql_object_list.append(company_candidate[i+1])
        sql_object_list.append(".")

    sql_object_list = sql_object_list[:-2]
    sql_part = " ".join(sql_object_list)
    # build sql
    sql = f'''
        SELECT *
        WHERE{{
            {sql_part} {company}
        }}
        '''
    # print(sql)
    response = send_post(sql)
    return response

def query_next_n_layer_company(company:str,layer:int):
    assert layer <= 9
    company_candidate = ["?a", "?b", "?c", "?d", "?e", "?f", "?g", "?h", "?i", "?j"]
    sql_object_list = []
    for i in range(layer):
        sql_object_list.append(company_candidate[i])
        sql_object_list.append("?p")
        sql_object_list.append(company_candidate[i+1])
        sql_object_list.append(".")

    sql_object_list = sql_object_list[1:-1]
    sql_part = " ".join(sql_object_list)
    # build sql
    sql = f'''
        SELECT *
        WHERE{{
            {company} {sql_part} 
        }}
        '''
    # print(sql)
    response = send_post(sql)
    return response
```
### 实验测试

#### python 测试代码

```python
def get_one_layer(company):
    print()
    print("get_one_layer:")
    pre_result = query_pre_n_layer_company(company_add_prefix_and_suffix(company),1)
    for r in pre_result["results"]["bindings"]:
        p = r["p"]["value"]
        a = r["a"]["value"]
        print(f"{company_delete_prefix_and_suffix(a)} -> {company_delete_prefix_and_suffix(company)}")
    print()
    next_result = query_next_n_layer_company(company_add_prefix_and_suffix(company),1)
    for r in next_result["results"]["bindings"]:
        p = r["p"]["value"]
        b = r["b"]["value"]
        print(f"{company_delete_prefix_and_suffix(company)} -> {company_delete_prefix_and_suffix(b)}")
    print()


def get_two_layer(company):
    print()
    print("get_two_layer:")
    pre_result = query_pre_n_layer_company(company_add_prefix_and_suffix(company),2)
    for r in pre_result["results"]["bindings"]:
        p = r["p"]["value"]
        a = r["a"]["value"]
        b = r["b"]["value"]
        print(f"{company_delete_prefix_and_suffix(a)} -> {company_delete_prefix_and_suffix(b)} -> {company_delete_prefix_and_suffix(company)}")
    print()
    next_result = query_next_n_layer_company(company_add_prefix_and_suffix(company),2)
    for r in next_result["results"]["bindings"]:
        p = r["p"]["value"]
        b = r["b"]["value"]
        c = r["c"]["value"]
        print(f"{company_delete_prefix_and_suffix(company)} -> {company_delete_prefix_and_suffix(b)} -> {company_delete_prefix_and_suffix(c)}")
    print()

def get_three_layer(company):
    print()
    print("get_three_layer:")
    pre_result = query_pre_n_layer_company(company_add_prefix_and_suffix(company),3)
    for r in pre_result["results"]["bindings"]:
        a = r["a"]["value"]
        b = r["b"]["value"]
        c = r["c"]["value"]
        print(f"{company_delete_prefix_and_suffix(a)} -> {company_delete_prefix_and_suffix(b)} -> {company_delete_prefix_and_suffix(c)} -> {company_delete_prefix_and_suffix(company)}")
    print()
    next_result = query_next_n_layer_company(company_add_prefix_and_suffix(company),3)
    for r in next_result["results"]["bindings"]:
        b = r["b"]["value"]
        c = r["c"]["value"]
        d = r["d"]["value"]
        print(f"{company_delete_prefix_and_suffix(company)} -> {company_delete_prefix_and_suffix(b)} -> {company_delete_prefix_and_suffix(c)} -> {company_delete_prefix_and_suffix(d)}")
    print()


if __name__ == "__main__":
    company = "C"
    get_one_layer(company)
    get_two_layer(company)
    get_three_layer(company)
```

#### 测试代码输出
```bash
$ python expr2_test.py 

get_one_layer:
B -> C

C -> D


get_two_layer:
A -> B -> C

C -> D -> E


get_three_layer:
E -> A -> B -> C

C -> D -> E -> A

```

## 任务三：

编写sparql语言实现环形持股查询，判断两家公司是否存在环形持股现象，环形持股是指两家公司彼此持有对方的股份。例如：输入“A”和“C”，判断两家公司是否存在环形持股。

### 实现思路：

先找出五跳内控股A的公司  
再找出五跳内控股C的公司  
如果C五跳内控股A且A五跳内控股C，那么存在环形持股  
    得到环形持股链路：  
        找到C到A的所有路径    
        找到A到C的所有路径  

### SPARQL查询实现

```
# A五跳内控股的公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/A> ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 ?d .
	?d ?p3 ?e .
	?e ?p4 ?f
}
# C五跳内控股的公司
select *
{
	<file:///F:/d2r-server-0.7/holder8.nt#holder_copy/C> ?p0 ?b .
	?b ?p1 ?c .
	?c ?p2 ?d .
	?d ?p3 ?e .
	?e ?p4 ?f
}

# 其余部分处理用python实现
```

### python 代码实现
```bash
def check_ring_hold(company1:str,company2:str):
    G1=nx.DiGraph()
    G1.add_node(company1)
    company1_query_result = query_next_n_layer_company(company_add_prefix_and_suffix(company1),5)
    for r in company1_query_result["results"]["bindings"]:
        b = company_delete_prefix_and_suffix(r["b"]["value"])
        c = company_delete_prefix_and_suffix(r["c"]["value"])
        d = company_delete_prefix_and_suffix(r["d"]["value"])
        e = company_delete_prefix_and_suffix(r["e"]["value"])
        f = company_delete_prefix_and_suffix(r["f"]["value"])
        G1.add_node(b)
        G1.add_node(c)
        G1.add_node(d)
        G1.add_node(e)
        G1.add_node(f)
        G1.add_edge(company1,b)
        G1.add_edge(b,c)
        G1.add_edge(c,d)
        G1.add_edge(d,e)
        G1.add_edge(e,f)
    G2=nx.DiGraph()
    G2.add_node(company2)
    company2_query_result = query_next_n_layer_company(company_add_prefix_and_suffix(company2),5)
    for r in company2_query_result["results"]["bindings"]:
        b = company_delete_prefix_and_suffix(r["b"]["value"])
        c = company_delete_prefix_and_suffix(r["c"]["value"])
        d = company_delete_prefix_and_suffix(r["d"]["value"])
        e = company_delete_prefix_and_suffix(r["e"]["value"])
        f = company_delete_prefix_and_suffix(r["f"]["value"])
        G2.add_node(b)
        G2.add_node(c)
        G2.add_node(d)
        G2.add_node(e)
        G2.add_node(f)
        G2.add_edge(company2,b)
        G2.add_edge(b,c)
        G2.add_edge(c,d)
        G2.add_edge(d,e)
        G2.add_edge(e,f)
    # A 持股 C ， C 持股 A
    found = False
    if company2 in G1.nodes() and company1 in G2.nodes():
        found = True
    if found:
        path1 = nx.all_simple_paths(G1,company1,company2)
        path2 = nx.all_simple_paths(G2,company2,company1)
    return found, path1, path2
```

### 实验测试

#### python 测试代码

```python
if __name__ == "__main__":
    found , path1, path2  = check_ring_hold("A","C")
    if found:
        print("A C 存在环形持股")

        print("paths from A to C")
        for path in path1:
            print(" -> ".join(path))

        print("paths from C to A")
        for path in path2:
            print(" -> ".join(path))
```

#### 实验结果

```bash
$ python expr3_test.py 
A C 存在环形持股
paths from A to C
A -> B -> C
paths from C to A
C -> D -> E -> A
```



























